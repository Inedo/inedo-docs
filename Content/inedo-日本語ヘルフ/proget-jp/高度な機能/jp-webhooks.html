---
title: "Webhook で自動化する方法"
order: 1
hidden: true
---

<p>WebhookでProGetを他のサービスに接続すると、ユーザに通知したり、自動化をされたワークフローをトリガーしたり、特定のイベントを監査したりできます。例えば、</p><ul><li>パッケージがフィードに追加されたとき、メッセージを送信する</li><li><a href="/docs/buildmaster/overview">BuildMaster</a>（リンク先英語）で、パッケージが別のフィード（例、開発中パッケージのフィードから、デプロイ可のパッケージのフィード）に移動したとき、パッケージをデプロイさせる</li><li>パッケージが削除された場合、サードパーティのツールにてメッセージを記録する</li></ul><p>この機能は、パッケージの公開やデプロイ、削除などのイベントが発生したとき、HTTP&nbsp;ベースの通知（ペイロード）を送信するWebhookを作成します。ワークフロー自動化サービス（Zappier、Microsoft&nbsp;Flowなど）やその他のツールのAPIにも、ペイロードを適合できます。</p><p>有料版もしくは体験版の&nbsp;ProGet&nbsp;で使用できます。</p><h2>Webhook<strong>の設定</strong></h2><p><strong>Webhook</strong>は&nbsp;[Administration (管理)] &gt; [Webhooks page (Webhookページ)]&nbsp;から、&nbsp;すべてまたは個別のフィードに対してそれぞれ設定できます。複数のWebhookの指定もできますが、実行される順序は保証されません。</p><p>使用上の注意：Webhookは基本的な通知とトリガーのみが目的です。複数のWebhookを「連鎖」させ、一連のシーケンシャル（順番が決まっている）イベントのオーケストレーション（自動化）をするのは避けてください。テストでは問題なく実行されても、Webhookの起動順序は予測できず、並行して発生してしまうことがあります。</p><p>Webhookはフィードと関連付けることができ、以下の要素があります：</p><ul><li>Id –&nbsp;システムが生成した固有の識別子</li><li>[Name (名前)] – UI&nbsp;（ユーザーインターフェイス）内やログのWebhookを特定するための固有でない識別子</li><li>[Event Type (イベントタイプ)] -&nbsp;イベントタイプの一種</li><li>URL -&nbsp;要求を送信するURL</li><li>[Conditional (コンディショナル/条件的)] -&nbsp;Webhookが実行されるべきか判断するために検証されるエクスプレッション</li><li>[Custom payload (カスタムペイロード)] -&nbsp;デフォルトペイロードの代わりに、送信されるリクエストをカスタマイズする</li><li>[Method (メソッド)] - GET, DELETE, POST, PUT, HEAD, OPTIONS, PATCHのいずれか</li><li>[Headers (ヘッダー)] - HTTPヘッダーの改行個別リスト</li><li>[Body (本文)] -&nbsp;送信されるリクエストの本文</li></ul><h2><strong>イベントタイプ</strong></h2><p><strong>Webhook</strong>は以下のイベントに対して設定できます：</p><ul><li>[added (追加)]&nbsp;- API、ウェブインターフェイス、もしくはドロップパスを使ってパッケージが追加される</li><li>[promoted (プロモーション)] - APIもしくはウェブインターフェイスを使ってパッケージがプロモーションされる</li><li>[deployed (デプロイ)] -&nbsp;デプロイ記録が追加される。特定のHTTPヘッダーがAPIベースのパッケージダウンロード中に送信される時に発生する</li><li>[deleted (削除)]&nbsp;- APIもしくはウェブインターフェイスを使ってパッケージが削除される</li><li>[purged (パージ)] -&nbsp;リテンションポリシーに基づいてパッケージが削除される</li></ul><h2><strong>コンディショナル</strong></h2><p>コンディショナル（条件）とは、Webhookが起動する前に検証される任意の式です。<a href="/docs/executionengine/reference/formal-specification#predicate-statement">OtterScriptの述語式</a>（リンク先英語）と同じ形式をとり、単項演算子&nbsp;（&nbsp;!&nbsp;）や等価演算子&nbsp;（&nbsp;==&nbsp;と&nbsp;!=&nbsp;）、ブーリアン演算&nbsp;（&amp;&amp;&nbsp;と&nbsp;||&nbsp;）や丸括弧で構成されます。</p><p>以下が式の例とその結果です。</p><table><thead><tr><th>式</th><th>結果</th></tr></thead><tbody><tr><td>$FeedType == NuGet</td><td>$FeedType == NuGetフィードタイプが&nbsp;NuGet&nbsp;の場合、Webhook&nbsp;が実行される。&nbsp;大文字と小文字を区別し比較するので、nugetと入力しても常にfalseで評価されるので注意が必要</td></tr><tr><td>true</td><td>Webhookは常に実行されるl</td></tr><tr><td>!true</td><td>Webhookは実行されない</td></tr><tr><td>true &amp;&amp; false</td><td>Webhookは実行されない</td></tr><tr><td>$CustomVar == true</td><td>$CustomVarが定義された変数であり、結果が&nbsp;"true "であれば、Webhookは実行される。変数が定義されていない場合はエラーが生じる</td></tr></tbody></table><h2><strong>デフォルトペイロード</strong></h2><p>デフォルトの場合、ProGet&nbsp;はシンプルな&nbsp;JSON&nbsp;ベースのオブジェクトを&nbsp;POST&nbsp;します。その際、パッケージ情報とイベントタイプを含むキー/値を持ちます。固有データのパッケージを送信する場合、変数を使用するのでご注意ください。</p><h3>ヘッダー：</h3><pre><code class="lang-powershell" data-language="powershell">Content-Type=application/json
</code></pre><h3>内容</h3><pre><code class="lang-powershell" data-language="powershell">$ToJson(%(
	feed: $FeedName,	
	package: $PackageId,	
	version: $PackageVersion,	
	hash: $PackageHash,
	packageType: $FeedType,	
	event: $WebhookEvent,
	user: $UserName
}
</code></pre><h2><strong>ワークフロー自動化サービス</strong></h2><p>基本的な&nbsp;HTTP&nbsp;リクエストだけで特定のタスクを実行できない場合、サードパーティのワークフロー自動化サービスを利用し、ProGet&nbsp;と自動化をしたいツールの間のブリッジとして機能できます。</p><p>Zapier、IFTT、Microsoft Flow、elastic.io&nbsp;など、多くのホスト型やオンプレミスのワークフロー自動化サービスがあります。サービスの機能は少しずつ異なりますが、ProGet&nbsp;との統合方法はほとんど同じです。ProGet&nbsp;は自動化サービスに&nbsp;HTTP&nbsp;リクエストを送信します。自動化サービスはいくつかのワークフローをトリガーにし、他の&nbsp;API&nbsp;への追加リクエストをディスパッチできます。</p><p>例：Zapier</p><p>Zapier&nbsp;では、自動化ワークフローのことを&nbsp;Zaps（ザップ）と呼びます。有効にしたWebhookをトリガーとして新しいザップを作成すると、以下のようなURLを受信します。</p><p>https://zapier.com/hooks/catch/n/Lx2RH/</p><p>Zappier の Webhook は「シンプルで使いやすい」ことが特徴です。ProGet のデフォルトペイロードはシンプルな JSON ベースのキーと値のペアなので、&nbsp;この URL を使ってプロセスを始めましょう。</p><p>フィードの Webhook に Zap URL を入力し、指定したイベントが発生すると、&nbsp;ProGet は Zapier へのデータ送信を開始します。Zappier は、フィールド（フィード、グループ、名前、バージョンなど）を自動的にパースをします。</p><p>そして、それらの値をアウトバウンド統合に使うことができます。詳細やトラブルシューティングに関しては、<a href="https://zapier.com/help/create/code-webhooks">ZapierのWebhookドキュメンテーション</a>（リンク先英語）&nbsp;を参照してください。</p><h2>他のサービスへの認証</h2><p>それぞれのAPIは少しずつ違った形で認証を管理していますが、少なくとも&nbsp;2&nbsp;つのオプション（APIキーの使用か基本的なアクセス認証）のうちの&nbsp;1&nbsp;つが提示されます。どちらの認証方法もWebhook内で行うことができますが、カスタムペイロードが必要になるかもしれません。</p><p>API キーはクエリストリングやメッセージ本文、もしくは HTTP ヘッダーにある場合が多いです。それぞれ Webhook の適切な場所に追加しましょう。</p><p><a href="https://ja.wikipedia.org/wiki/Basic%E8%AA%8D%E8%A8%BC">Basic認証</a>は、HTTP と同義です。以下のように Webhook のヘッダーセクションに追加できます：</p><pre><code>Authorization:Basic $EncodeBasicAuth(username,password)
</code></pre><p>いずれの場合も、キーや名前、パスワードを蓄積するために変数を使うことをおすすめします。セキュアな状態にはできません（常にHTTP/S経由でプレインテキストとして送信される）が、難読化をして軽い不正アクセスを防いだり、別のWebhookでの再利用が簡単になったりします。</p><h2><strong>変数</strong></h2><p>変数を使って、APIキーなどの静的構成の情報、ユーザー名などのコンテンツ固有のデータ、バージョン番号などのパッケージのメタデータを組み合わせて、さまざまなカスタムペイロードを作成できます。</p><h2><strong>設定変数</strong></h2><p>設定変数は静的なので、グローバルまたはフィード上で定義できるキーと値のペアです。グローバル変数（大域変数）と同じ名前のフィードレベル変数を定義した場合、そのフィード上のコンテキストでイベントが発生した時にフィードレベル変数が使われます。</p><p>変数名は50文字以内で、数字&nbsp;（&nbsp;0-9&nbsp;）、大文字と小文字&nbsp;（&nbsp;a-Z&nbsp;）、ダッシュ&nbsp;（&nbsp;-&nbsp;）、&nbsp;アンダースコア&nbsp;（&nbsp;_&nbsp;）を使ったものが適用できます。ダッシュやアンダースコアを先頭や最後にはできません。</p><h2><strong>可変関数</strong></h2><p>デフォルトペイロードには&nbsp;$JSEncode($PackageGroup)&nbsp;のような式がよくあります。これらは可変関数と言い、いくつかのパラメータを受け取る代わりに何らかの値を返すものです。$FeedName , $PackageVersion , $Date&nbsp;などのビルトイン（組み込み）変数はすべて可変関数として&nbsp;実行されます。</p><p>可変関数と同じ名前の設定変数にもできますが、$FeedNameなどが実際のフィード名を返さないと混乱の原因になるので、あまりおすすめしません。同じ名前の設定変数がある場合、$FeedName()&nbsp;のようなパラメータリストを明確に指さない限り、名前の代わりに値が使われます。</p><p>可変関数は拡張可能なため、<a href="/docs/proget/administration/extensions">Inedoの拡張機能</a>（リンク先英語）を使い独自の関数を書くことができます。</p><h2><strong>パッケージのメタデータを読み取る</strong></h2><p>可変関数はパッケージからメタデータを抽出するために使われます。また、$PackageName や　$PackageVersion&nbsp;など、すべてのパッケージが共通のメタデータにアクセスするための組み込み関数がいくつかあります。また、$PackageProperty()&nbsp;関数を使うこともできます。</p><p>例えば、ユニバーサルパッケージで $PackageProperty(_sourceTarget) を使用した場合、_sourceTarget プロパティーが返されます。このようなプロパティーがない場合、ログにエラーが記録され Webhook は実行されません。</p><p>ただし、PackageProperty function（パッケージプロパティー関数）に第2引数（defaultText）を指定すると実行されます。つまり、$PackageProperty(_sourceTarget, unspecified)は_sourceTarget&nbsp;の値か不特定の値を返します。</p><h2><strong>エスケープの$と解けない変数</strong></h2><p>変数のように「見える」、$で始まり文字が続くものは、すべてパースとして解析され評価されます。設定変数や可変関数が見つからない場合、エラーがログに記録され、リクエストも完了されません。これは$PackagNameのようなタイプミスを追跡するのに役立ち、必須と言ってもいい機能です。</p><p>ペイロードのどこかに$が必要な場合、アポストロフィ&nbsp;&nbsp;を使って、「$」&nbsp;といった風にエスケープする必要があります。&nbsp;アポストロフィー&nbsp;を使う場合は、「``」でエスケープします。r ,n, `tの場合は空白文字も使えます。</p><p><strong>組み込み変数</strong></p><table><thead><tr><th>変数</th><th>結果</th></tr></thead><tbody><tr><td>$WebhookName</td><td>稼働中のWebhook名が表示される</td></tr><tr><td>$WebhookId</td><td>稼働中のWebhookIDが表示される</td></tr><tr><td>$WebhookEvent</td><td>イベント名が表示される</td></tr><tr><td>$FeedId</td><td>コンテキスト内のフィードIDが表示される</td></tr><tr><td>$FeedName</td><td>コンテキスト内のフィード名が表示される</td></tr><tr id="c1da0c0f-97e5-48d0-9a7b-b19ec5f4468f"><td>$FeedType</td><td>NuGet、Chocolatey、PowerShell、{…}などコンテキスト内のフィードタイプが表示される</td></tr><tr><td>$Date(format)</td><td>同様</td></tr><tr id="418e729e-cec0-4865-a103-8f6835706632"><td>$PackageGroup</td><td>パッケージのグループ名が表示される、もしくは空欄</td></tr><tr id="1bc11681-6ec0-4ca7-aea8-4ad56a82fd0d"><td>$PackageName</td><td>パッケージ名が表示される、もしくはIDのみの場合は空欄</td></tr><tr id="fa6b63ca-6a51-4619-96b2-823859655bab"><td>$PackageId</td><td>パッケージのIDが表示される</td></tr><tr id="52906f7f-4935-489f-8f07-9d31ff1a0e44"><td>$PackageVersion</td><td>パッケージのバージョンが表示される</td></tr><tr id="1c2712c8-7f5c-485e-a499-2a360325d6b3"><td>$PackageHash</td><td>パッケージのハッシュが表示される</td></tr><tr id="24e12d56-2782-4c31-88ad-14f16a3ebf1d"><td>$PackageProperty(name, default)</td><td>メタデータから任意のプロパティーが表示される。[default (デフォルト)]&nbsp;を指定しプロパティーが存在しない場合、発生したエラーの代わりに、そのテキストが表示される</td></tr><tr><td>$Username</td><td>イベントを開始したユーザーの名前が表示される。サービス&nbsp;（例：ドロップパス）&nbsp;や&nbsp;[Anonymous (匿名)]&nbsp;によって動作させられた場合、SYSTEMになる</td></tr><tr><td>$EncodeBasicAuth(username,password)</td><td>基本的な認証リクエストで使用されるbase64文字列が表示される</td></tr><tr><td><a>$JSEncode(s)</a></td><td>javascript/JSON文字列で使用するためにエンコードされた値が表示される</td></tr><tr><td>$Coalesce(s, …)</td><td>引数から最初の空白以外の値が表示される</td></tr></tbody></table><p><strong>エラー処理とデバッグ</strong></p><p>ProGet は作業を続行するために外部サーバからのレスポンスを待機しません。エラーが発生した場合（不正なHTTPステータスコードやネットワークレベルの問題）、ProGetの&nbsp;[Diagnostics Center (診断センター)]&nbsp;に保存されます。&nbsp;エラーは、[Administration (管理)] &gt; [Diagnostics Center (診断センター)]&nbsp;に移動し、&nbsp;[View Messages (メッセージの表示)]&nbsp;ボタンをクリックして表示します。&nbsp;Webhookメッセージのみを表示するカテゴリフィルタもあります。</p><p>一部のエラーが発生すると、HTTPリクエストができなくなります。（例：変数を置き換えられない、または無効なURLがあるなど）</p><p>Webhook リクエストは、イベントが発生した場所に応じてウェブかサービスから行われます。例えば、パッケージのプロモーションリクエストは、リクエストを受け取ったWebノードから来ます。それに対して、パッケージの追加リクエストは&nbsp;Web&nbsp;ノード&nbsp;（Web ui&nbsp;や&nbsp;API）&nbsp;やサービス&nbsp;（ドロップ、パス）&nbsp;から来る可能性があります。</p><p><strong>このトピックについての詳細：</strong></p><p>o<a href="/docs/proget/administration/proget-notifications-webhooks/proget-notifiers-slack-integration">Slackへの接続</a></p><p>o<a href="/docs/proget/administration/proget-notifications-webhooks/proget-notifiers-teams-integration">Teamsへの接続</a></p>