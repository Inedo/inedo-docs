---
title: "UPack Command-line Interface"
order: 2
---

<section class="infoBox"><div class="content">The Command-line reference is available on <a href="https://github.com/Inedo/upack#upackexe">GitHub</a>.</div></section><p>upack.exe is a cross-platform command-line tool for creating and installing universal packages; you can also see which packages are installed on a machine.</p><p><iframe width="600" height="337" src="https://www.youtube.com/embed/blGLta0cvPA" frameborder="0" allowfullscreen="true"></iframe></p><h3 id="installation">Download, Installation, &amp; Source Code</h3><p>upack.exe is a stand-alone program and does not require installation. Visit the <a href="https://github.com/Inedo/upack/releases" target="_blank">GitHub Releases</a> section to download the latest version.</p><p>The source code for upack.exe is hosted on <a href="https://github.com/Inedo/upack" target="_blank">GitHub</a>.</p><h2 id="creating-publishing">Creating and Publishing a Universal Package with upack.exe</h2><h4><em>Prerequisites:</em></h4><ul class="docs"><li>Download the latest upack.exe from any of the locations here: <a href="https://inedo.com/upack/download" target="_blank">https://inedo.com/upack/download</a></li><li>Download Accounts.zip from: <a href="http://cdn.inedo.com/downloads/upack/Accounts.zip">http://cdn.inedo.com/downloads/upack/Accounts.zip</a></li><li>An installed instance of ProGet with a Universal feed configured</li><li>Basic Shell knowledge (for Linux users), or Command Prompt / PowerShell (for Windows users)</li><li>If running the .NET Core version (required for Linux users) of upack, you will need to install the <a href="https://dotnet.microsoft.com/download/dotnet-core/3.1">.NET Core 3.1 Runtime</a>. To learn how to run .NET Core version of upack, visit our command line reference on <a href="https://github.com/Inedo/upack#upackexe">GitHub</a>.</li></ul><h3 id="overview">Overview</h3><p>In this tutorial, we will take an existing website and package it into a Universal Package using the upack.exe tool. The files in Accounts.zip are just the build output of a basic .NET web application. For those unfamiliar with .NET, it could just as easily be a Java WAR file, a collection of PHP files, or even static HTML.</p><p>We'll also be using a PowerShell prompt (hence the <code>PS &gt;</code>) and <code>C:\tmp\accounts</code> as a working directory, but you can do this on Linux or in the command prompt just the same.</p><h3 id="creating">Creating a Package</h3><p>In this step, we will create a Universal Package. The format of the package is easy to understand and, thanks to some basic package properties, allows consistent deployment and distribution of the contents of Accounts.zip.</p><p class="info"><strong>Note:</strong> In a typical usage scenario, the "pack" step would be executed by a Continuous Integration server such as TeamCity or Jenkins immediately after the build output is generated.</p><p>To begin, we will download the Accounts.zip file and extract its contents into a temporary directory. Additionally, we will download upack.exe to a directory already included in the <code>PATH</code> environment variable.</p><p>In PowerShell, navigate to <code>C:\tmp\accounts</code>, and enter the following command to package the contents into a Universal Package:</p><pre>PS C:\tmp\accounts&gt; upack pack . --name=Accounts --version=1.0.0 --title="Accounts Website" --description="This package contains the build output for the Accounts demo website."</pre><p>This will generate a universal package named <code>Accounts-1.0.0.upack</code> in the same directory.</p><h3 id="pushing">Pushing a package to a Universal feed in ProGet</h3><p>Once a package is created, we can publish it to a Universal feed.</p><p><strong>Note</strong>: In a typical usage scenario, the "push" step would also be performed by a Continuous Integration Server sometime after package creation.</p><p>Before we can push the package, we need to determine the endpoint of the ProGet feed to use as the push source. After logging into ProGet and accessing the feed, make a note of the endpoint URL:</p><p><img src="/resources/docs/api-endpoint-url.png" class="fr-fil fr-dib"></p><p>With this value, we can now push our newly generated package into the feed using the following PowerShell command:</p><pre>PS C:\tmp\accounts&gt; upack push Accounts-1.0.0.upack http://progetint/upack/Universe/ --user=Admin:Admin</pre><p>Naturally, <code>Admin:Admin</code> should be replaced with a valid username/password combination for the specific feed, or omitted entirely to authenticate as the current Windows user or anonymously depending on how ProGet is configured.</p><p>Once the package is published to the feed successfully, we can view the package details in ProGet:</p><p><img src="/resources/docs/package-details-pg.png" class="fr-fil fr-dib"></p><h3 id="finding-installing">Finding and installing a package to install on a server</h3><p>Once the package is pushed to ProGet, it can be installed on any server that can access ProGet. In PowerShell, enter the following command to install the latest package contents to an existing directory:</p><pre>PS C:\tmp\accounts&gt; upack install Accounts --source=http://progetint/upack/Universe/ --target=.\install</pre><p>This will extract the package contents of the "Universe" feed in ProGet into <code>C:\tmp\accounts\install</code>.</p><h3 id="listing-packages">Listing installed packages on a server</h3><p>Once a package has been installed, upack.exe can query the Universal Package Registry on the local machine for installed packages with the list command:</p><pre>PS C:\tmp\accounts&gt; upack list</pre><p>After performing the steps above, this list will contain (at a minimum):</p><pre>Accounts 1.0.0
From http://progetint/upack/Universe/
Installed to C:\tmp\accounts\install on 2018-04-30T17:01:51.8197700-04:00
Installed by thoven using upack/2.2.0.1</pre><p>This list is not limited to what is installed by upack.exe, the Universal Package Registry will also contain packages installed from Otter, BuildMaster, and Romp.</p><h3 id="verifying">Verifying a downloaded package hash against a Universal feed</h3><p>We may obtain a package from a source other than installing it directly from ProGet, or it may have been obtained from another universal feed (i.e. the package was promoted ). In this case, it is useful to verify that the contents of the package are identical. This can be done using the verify command:</p><pre>PS C:\tmp\accounts&gt; upack verify Accounts-1.0.0.upack http://progetint/upack/Universe/ </pre><p>The result of this command will either indicate that the hashes match, or issue an error to standard error if they are different.</p><p>If you only need to view the hash, you can use the <code>hash</code> command:</p><pre>PS C:\tmp\accounts&gt; upack hash Accounts-1.0.0.upack</pre><p>If the exact same <code>pack</code> command was used as described in this tutorial (and we haven’t changed Accounts.zip on our end), the output will be:</p><pre>0633d10b2223cd9ce94ca70e298c4edb752d6028</pre><p>Of course, this is a standard SHA1 hash in hexadecimal format, so any existing tools (7zip, sha1sum, etc.) can be used to obtain a package hash. This hash could then be quickly compared to the SHA1 value displayed within ProGet to ensure the package contents are identical.</p><h3 id="repackaging">Repackaging an existing package</h3><p>When deploying packages, it is common to rewrite the package metadata, such as version information (e.g., removing pre-release identifiers ), adding/appending descriptions, or changing the group name. This is where repackaging comes in: repackaging involves creating a new package from an existing package that has exactly the same content as the original package. As the metadata of the package changes, a history of package names and versions is also recorded for auditing purposes.</p><p>The <code>repack</code> command can be used for this purpose; it will effectively create a new package with the exact same contents but different metadata. The newly created package will default to any metadata property values of the existing package, and the <code>repack</code> command accepts any property supported by the pack command. Alternatively, a upack.json file with values will be merged into the source package’s upack.json file. Here are some common use cases for the <code>repack</code> command:</p><h4 id="changing-version">Changing Package Version</h4><pre>PS C:\tmp\accounts&gt; upack repack Accounts-1.0.0-RC007.upack --version=1.0.0</pre><h4 id="add-metadata">Add metadata elements from a custom upack.json file</h4><p><em>Note that when specifying the "manifest" file argument, &nbsp;arguments to overwrite other metadata (like version) will be ignored.</em></p><pre>PS C:\tmp\accounts&gt; upack repack Accounts-1.0.0.upack --manifest=additional-upack.json --overwrite</pre><p><em>additional-upack.json contents:</em></p><pre>{
  "description": "This additional metadata will overwrite the package's description, or add one if no description property exists",
  "tags": ["repackaged"]
}</pre>